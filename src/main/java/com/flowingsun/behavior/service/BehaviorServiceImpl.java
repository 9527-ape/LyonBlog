package com.flowingsun.behavior.service;import com.alibaba.fastjson.JSON;import com.flowingsun.article.entity.Article;import com.flowingsun.behavior.dao.*;import com.flowingsun.behavior.dto.BehaviorStatus;import com.flowingsun.behavior.entity.*;import com.flowingsun.behavior.entity.Collection;import com.flowingsun.behavior.vo.PictureQuery;import com.flowingsun.common.annotation.MethodExcuteTimeLog;import com.flowingsun.common.dao.RedisDAO;import com.flowingsun.common.utils.InfoCountUtils;import com.flowingsun.user.dao.UserMapper;import com.flowingsun.user.entity.User;import net.coobird.thumbnailator.Thumbnails;import org.apache.commons.lang.StringUtils;import org.apache.log4j.Logger;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authz.UnauthenticatedException;import org.apache.shiro.authz.annotation.RequiresPermissions;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import javax.servlet.http.HttpServletRequest;import java.io.*;import java.sql.Timestamp;import java.text.SimpleDateFormat;import java.util.*;import java.util.List;import java.util.logging.Level;import java.util.stream.Collectors;@Service("behaviorService")public class BehaviorServiceImpl implements BehaviorService {    private static Logger logger = Logger.getLogger(BehaviorServiceImpl.class);    private static final Integer SUCCESS=1;    private static final Integer FAIL=0;    private final String NGINX_STATIC_DIRPATH = "/usr/local/nginx/html";    private final String USER_SCREENSHOT_DIRPATH = "/static/userFile/images/screenShots";    private final String TEMP_IMAGE_PATH = "/static/userFile/images/temp";    private final String TEMP_VIDEO_PATH = "/static/userFile/videos/temp";    private final String USER_HEADIMAGE_DIRPATH = "/static/userFile/images/headImages";    private final String ZHIHU_DOWNLOADER_PATH = "/usr/local/software/Video-Downloader/zhihu.py";    //private final String ZHIHU_DOWNLOADER_PATH = "/home/lyon/CodingKit/software/VideoDownload/Video-Downloader/zhihu.py";    // phantomjs主程序地址    private final String WINDOWS_PHANTOMJS_BIN_PATH = "C:\\CodingKit\\phantomjs-2.1.1-windows\\bin\\phantomjs.exe";    // 调用phantomjs的js地址    private final String WINDOWS_PHANTOMJS_JS_PATH = "C:\\CodingKit\\phantomjs-2.1.1-windows\\othersFile\\rasterize.js";    @Autowired    private RedisDAO redisDAO;    @Autowired    private ThankMapper thankMapper;    @Autowired    private CollectionMapper collectionMapper;    @Autowired    private PictureMapper pictureMapper;    @Autowired    private CommentMapper commentMapper;    @Autowired    private CommentLikeMapper commentLikeMapper;    @Autowired    private DiscussionMapper discussionMapper;    @Autowired    private UserMapper userMapper;    @Autowired    private UrlCollectionMapper urlCollectionMapper;    /**     *@Author Lyon[flowingsun007@163.com]     *@Date 18/09/10 22:26     *@Param [commentBean, request]     *@Return java.lang.String     *@Description setComment     * 评论文章     */    @Override    @MethodExcuteTimeLog    public String setComment(Comment commentBean, HttpServletRequest request) {        try {            Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");            if (userId != null) {                commentBean.setUserid(userId);                if (commentMapper.insertSelective(commentBean).equals(SUCCESS)){                    this.updateBlogCommentCount();                    return "setComment_success";                }else{                    return "setComment_fail_插入数据库失败";                }            }else {                return "setComment_fail_未登录";            }        }catch(Exception e){            logger.error("setComment(Comment commentBean, HttpServletRequest request)执行Error",e);            return "setComment_fail_exception";        }    }    /**     *@Author Lyon[flowingsun007@163.com]     *@Date 18/09/10 22:26     *@Param [thankBean, request]     *@Return java.lang.String     *@Description setThank----给文章点感谢     *点赞逻辑：先取用户userId，如果为空则直接返回不为空则进行下面的判断：     * 1.查询用户点感谢记录，如果==0，则表示没有感谢记录，进行点赞行为；     * 如果     */    @Override    @MethodExcuteTimeLog    @Transactional(rollbackFor = Exception.class)    public String setThank (Thank thankBean, HttpServletRequest request){        try {            Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");            if(userId!=null){                thankBean.setUserid(userId);                //如果点感谢记录数>0次，则清空记录(取消感谢)                if(thankMapper.selectThankNumByThankbean(thankBean)>0){                    //否则清空点赞记录                    thankMapper.deleteByUserIdAndArticleId(userId, thankBean.getArticleid());                    this.updateBlogThankCount();                    return "removeThank_success";                }else{                    //否则进行'点感谢'操作                    thankBean.setThankdate(new Timestamp(new Date().getTime()));                    if (SUCCESS == thankMapper.insertThank(thankBean)) {                        this.updateBlogThankCount();                        return "setThank_success";                    }                }            }            return "setThank_fail_未登录";        } catch (Exception e) {            logger.error("setThank (Thank thankBean, HttpServletRequest request)执行Error：",e);            return "setThank_fail_exception";        }    }    @Override    @MethodExcuteTimeLog    public String setCollect(Collection collectionBean, HttpServletRequest request) {        try {            Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");            if(userId!=null){                collectionBean.setUserid(userId);                if (collectionMapper.selectCollectionCountByCollectionbean(collectionBean).equals(0)) {                    collectionBean.setCollectdate(new Timestamp(new Date().getTime()));                    if (SUCCESS == collectionMapper.insertCollection(collectionBean)) {                        this.updateBlogCollectCount();                        return "collect_success";                    }                } else {                    collectionMapper.deleteByUserIdAndArticleId(userId, collectionBean.getArticleid());                    this.updateBlogCollectCount();                    return "removeCollect_success";                }            }            return "collect_fail_未登录";        } catch (Exception e) {            logger.error("setCollect(Collection collectionBean, HttpServletRequest request)执行Error：",e);            return "collect_fail_exception";        }    }    @Override    @MethodExcuteTimeLog    public BehaviorStatus getUserBehavior(Long userid) {        BehaviorStatus behaviorBean = new BehaviorStatus();        behaviorBean.setCollectionCount(collectionMapper.selectCollectionCountByUserid(userid));        behaviorBean.setCommentCount(commentMapper.selectCommentCountByUserid(userid));        behaviorBean.setThankCount(thankMapper.selectThankCountByUserid(userid));        behaviorBean.setCollectionList(collectionMapper.selectCollectionsByUserid(userid));        return behaviorBean;    }    @Override    @MethodExcuteTimeLog    public String getUserArticleCollections(HttpServletRequest request) {        Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");        List<Collection> collections = collectionMapper.selectCollectionsByUserid(userId);        String result = JSON.toJSONString(collections);        return result;    }    @Override    @MethodExcuteTimeLog    public String setCommentLike(CommentLike bean, HttpServletRequest request) {        try {            Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");            if (userId != null) {                bean.setUserid(userId);                if (commentLikeMapper.selectLikeCountByCommentLikeBean(bean)==FAIL) {                    bean.setLikedate(new Timestamp(new Date().getTime()));                    if (commentLikeMapper.insertSelective(bean)==SUCCESS)                        return "setCommentLike_success";                    else                        return "setCommentLike_fail_exception";                } else {                    return "setCommentLike_fail_重复点赞";                }            }else {                return "setCommentLike_fail_未登录";            }        }catch(Exception e){            logger.error("setCommentLike(CommentLike bean, HttpServletRequest request)执行Error：",e);            return "setCommentLike_fail_exception";        }    }    @Override    @MethodExcuteTimeLog    public String setCommentDiscussion(Discussion discussion, HttpServletRequest request) {        try {            Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");            discussion.setDiscussdate(new Timestamp(new Date().getTime()));            if (userId != null) {                discussion.setUserid(userId);                if (discussionMapper.insertSelective(discussion)==SUCCESS)                    return "setCommentDiscussion_success";                else                    return "setCommentDiscussion_fail_exception";            }else {                return "setCommentDiscussion_fail_未登录";            }        }catch(Exception e){            logger.error("setCommentDiscussion(Discussion discussion, HttpServletRequest request)执行Error：",e);            return "setCommentDiscussion_fail_exception";        }    }    @Override    public String getMoneyDonatePage(HttpServletRequest request){        return "/user/donateMoney";    }    /**     *@Author Lyon[flowingsun007@163.com]     *@Date 18/06/4 19:22     *@Description saveUserImage     * 配合imageUpload()使用，用来将上传到服务器的单个图片路径存储到数据库     */    @Override    public boolean saveUserImage (Picture picture){        if (picture != null) {            return (pictureMapper.insert(picture) != FAIL) ?  true :  false;        }        return false;    }    /**     *@Author Lyon[flowingsun007@163.com]     *@Date 18/06/4 19:24     *@Description imageUpload     * 利用MultipartHttpServletRequest、MultipartFile等，     * 用来上传文件到服务器存储，同时将文件的路径，用saveUserImage()保存至数据库。     * @Param request session     * @Return 传回String类型的消息-resultInfo,用于前端显示。     */    @Override    public String imageUpload (MultipartHttpServletRequest request,String description){        Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");        if (userId == null) {            return "用户未登录！";        }else{            if(description==null){                description="";            }            String resultInfo = "";            Timestamp dateTime = new Timestamp(new Date().getTime());            User user = redisDAO.getRedisUser(userId);            //缓存未命中，从数据库读user            if(user==null){                user = userMapper.selectByPrimaryKey(userId);            }            try {                Iterator<String> fileNames = request.getFileNames();                while (fileNames.hasNext()) {                    //把fileNames集合中的值打出来                    String fileName = fileNames.next();                    /*                     * request.getFiles(fileName)方法即通过fileName这个Key, 得到对应的文件                     * 集合列表. 只是在这个Map中, 文件被包装成MultipartFile类型                     */                    List<MultipartFile> fileList = request.getFiles(fileName);                    Picture picture = new Picture();                    picture.setUserid(userId);                    picture.setCreatedate(dateTime);                    String contextPath = "/static/userFile/images/";                    String dirPath = NGINX_STATIC_DIRPATH + contextPath;                    File dirfile = new File(dirPath);                    if(!dirfile.exists()){                        dirfile.mkdirs();                    }                    dirfile.setReadable(true, false);                    dirfile.setWritable(true,false);                    dirfile.setExecutable(true,false);                    //遍历文件列表                    Iterator<MultipartFile> fileIte = fileList.iterator();                    while (fileIte.hasNext()) {                        //获得每一个文件                        MultipartFile multipartFile = fileIte.next();                        //获得原文件名                        String originalFilename = multipartFile.getOriginalFilename();                        if ("" == originalFilename) {                            resultInfo += "空文件😶！;";                            continue;                        }                        resultInfo += ("原文件名:" + originalFilename + ";");                        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");                        String dateString = sdf.format(new Date());                        String newfileName =  userId.toString() + "_" + user.getUsername() + "_" + dateString + "_" +originalFilename;                        //保存文件至Nginx服务器静态目录下                        String fileContextPath = contextPath + newfileName;                        File nginxFile = new File(NGINX_STATIC_DIRPATH + fileContextPath);                        if (!(nginxFile.exists())) {                            try{                                //此处若文件已存在,则会抛出IllegalStateException                                multipartFile.transferTo(nginxFile);                                nginxFile.setReadable(true, false);                            }catch (IllegalStateException i){                                System.out.println("IllegalStateException:文件已存在:"+nginxFile.getName());                            }                        }                        //String name = multipartFile.getName();                        resultInfo += ("文件名:" + newfileName + ";");                        //multipartFile.getSize()获取文件大小, 单位为字节,用工具类getPrintSize()处理后转化为B、MB、KB、GB                        String size = InfoCountUtils.getPrintSize(multipartFile.getSize());                        resultInfo += ("文件大小:" + size);                        if (multipartFile.getSize() > 0) {                            //将文件路径存入数据库                            picture.setDetails(description);                            picture.setFilepath(fileContextPath);                            if(!saveUserImage(picture))                                resultInfo += "图片已存服务器，存DB失败;";                            else                                resultInfo += "图片已存服务器，存DB成功;";                        }                    }                }            } catch (IllegalStateException f) {                resultInfo += "IllegalStateException:上传状态错误，可能是从非法页面提交上传";                logger.error(resultInfo,f);                f.printStackTrace();            } catch (UnauthenticatedException g) {                resultInfo += "UnauthenticatedException:用户无上传图片权限";                logger.error(resultInfo,g);            } catch (Exception e) {                resultInfo += "Exception:e";                logger.error(resultInfo,e);            } finally {                return resultInfo;            }        }    }    /**     *@Author Lyon[flowingsun007@163.com]     *@Date 18/07/15 22:55     *@Param [pictureQuery]     *@Return com.flowingsun.behavior.vo.PictureQuery     *@Description getUserImages     * 查询用户Timeline上传的图片,默认查询时间为近一年的,根据pictureQuery来查询     * (默认查询从第一页开始，每页20条数据)     */    @Override    public PictureQuery getUserImages (PictureQuery pictureQuery){        Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");        if (userId != null) {            User user = redisDAO.getRedisUser(userId);            //缓存未命中，从数据库读user}            if(user==null){user = userMapper.selectByPrimaryKey(userId);}            pictureQuery.setUserid(user.getId());            pictureQuery.setUsername(user.getUsername());            //设置照片查询时间段,默认为最近一年            Calendar toDate = Calendar.getInstance();            Calendar fromDate = Calendar.getInstance();            fromDate.add(Calendar.DAY_OF_MONTH,-365);            pictureQuery.setStartDate(fromDate.getTime());            pictureQuery.setEndDate(toDate.getTime());            //查询相应时间段内照片总数            Integer total = pictureMapper.selectCountByQueryDateRange(pictureQuery);            if(total!=null&&total>0){                pictureQuery.setTotal(total);                List<PictureQuery> pictureQueryList = pictureMapper.selectByQueryDateRange(pictureQuery);                pictureQuery.setDataList(pictureQueryList);            }        }        return pictureQuery;    }    /**     *@Author Lyon[flowingsun007@163.com]     *@Date 18/07/15 21:31     *@Param [article, userId]     *@Return com.flowingsun.article.entity.Article     *@Description getUserArticleBehavior     * 用于判断给定的用户id在某篇文章下的用户行为,譬如点赞、评论等     */    @Override    @MethodExcuteTimeLog    public Article getUserArticleBehavior(Article article, Long userId) {        BehaviorStatus behaviorBean = new BehaviorStatus();        Integer articleId = article.getId();        byte flag=1;        if(thankMapper.selectThankStatusByAidUid(userId,articleId)>=1){            behaviorBean.setThankStatus(flag);        }        if(commentMapper.selectCommentStatusByAidUid(userId,articleId)>=1){            behaviorBean.setCommentStatus(flag);        }        if(collectionMapper.selectCollectionStatusByAidUid(userId,articleId)>=1){            behaviorBean.setCollectStatus(flag);        }        article.setBehaviorStatus(behaviorBean);        return article;    }    /**     *@Author Lyon[flowingsun007@163.com]     *@Date 18/07/15 21:32     *@Param [articleList, userId]     *@Return java.util.List<com.flowingsun.article.entity.Article>     *@Description getUserArticleListBehavior     * 此方法用于加载根据cId或tag筛选的分类文章或中特定用户id下的浏览点赞评论等行为信息,具体通过遍历每篇文章调用getUserArticleBehavior()查询。     */    @Override    @MethodExcuteTimeLog    public List<Article> getUserArticleListBehavior(List<Article> articleList,  Long userId) {        List<Article> articles = articleList.stream().map(e->{            return getUserArticleBehavior(e,userId);        }).collect(Collectors.toList());        return articles;    }    @Async    public void updateBlogThankCount(){        String s = String.valueOf(thankMapper.selectThankCount());        redisDAO.setString("thankCount",s);    }    @Async    public void updateBlogCommentCount(){        String s = String.valueOf(commentMapper.selectCommentCount());        redisDAO.setString("commentCount",s);    }    @Async    public void updateBlogCollectCount(){        String s = String.valueOf(collectionMapper.selectCollectionCount());        redisDAO.setString("collectionCount",s);    }    @Override    public String getScreenShot(String url)throws Exception{        String tempPath = USER_SCREENSHOT_DIRPATH;        String imgagePath = tempPath + File.separator + System.currentTimeMillis() + ".png";;        String cmd = WINDOWS_PHANTOMJS_BIN_PATH + " " + WINDOWS_PHANTOMJS_JS_PATH + " " + url + " " + imgagePath;        //Java中使用Runtime和Process类调用命令行执行PhantomJS        Process process = Runtime.getRuntime().exec(cmd);        try(InputStream inputStream = process.getInputStream();            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));        ){            StringBuffer sb = new StringBuffer();            String tmp = "";            while ((tmp = reader.readLine()) != null) {                sb.append(tmp);            }        }        process.destroy();        return imgagePath;    }    @Override    public UrlCollection collectUrl(UrlCollection bean)throws Exception {        Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");        if (userId != null) {            User user = redisDAO.getRedisUser(userId);            //缓存未命中，从数据库读user}            if(user==null){                user = userMapper.selectByPrimaryKey(userId);            }            if(user!=null){                bean.setUserId(userId);                urlCollectionMapper.insertSelective(bean);            }else {                throw new Exception("该用户ID不存在！");            }        }else{            throw new Exception("用户未登录！");        }        return bean;    }    @Override    public String setUserHeadImage(MultipartFile multipartFile, HttpServletRequest request) {        String resultInfo = "";        if(multipartFile==null){            resultInfo = "请勿上传空文件";            return resultInfo;        }else{            Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");            if (userId == null) {                resultInfo = "用户未登录！";                return resultInfo;            }else{                String contextPath = USER_HEADIMAGE_DIRPATH;                String originFileName = multipartFile.getOriginalFilename();                String fileName = "thumb-" + originFileName;                String dirPath = NGINX_STATIC_DIRPATH + contextPath + File.separator;                try {                    //上传头像图片至nginx                    File dir = new File(dirPath);                    if(!dir.exists()){                        dir.mkdirs();                    }                    File nginxFile = new File(dirPath + File.separator + originFileName);                    nginxFile.setReadable(true, false);                    multipartFile.transferTo(nginxFile);                    //剪裁原始图片至最大256x256                    Thumbnails.of(nginxFile)                            .size(256, 256)                            .outputQuality(1.0)                            .toFile(dirPath + fileName);                    resultInfo += "头像上传服务器成功！";                    //更新数据库blog_user表headImage字段                    if(1==userMapper.updateUserHeadImage(userId,contextPath + File.separator + fileName))                        resultInfo+="数据库用户头像更新成功";                    else                        resultInfo+="数据库用户头像更新失败";                    //将图片信息存入数据库picture表                    Picture picture = new Picture();                    picture.setUserid(userId);                    picture.setDetails("用户头像-userID："+userId);                    picture.setCreatedate(new Date());                    picture.setFilepath(contextPath + File.separator + fileName);                    if(saveUserImage(picture)){                        resultInfo+=";图片存数据库成功！";                        User user = userMapper.selectByPrimaryKey(userId);                        if(user!=null){                            redisDAO.setRedisUser(user);                        }                    }                    else{                        resultInfo+=";图片存数据库失败！";                    }                } catch (IOException e) {                    resultInfo += "IOException:multipartFile.transferTo出错！";                    logger.error(resultInfo,e);                } catch (IllegalStateException f) {                    resultInfo += "IllegalStateException:上传状态错误，可能是从非法页面提交上传";                    logger.error(resultInfo,f);                } catch (UnauthenticatedException g) {                    resultInfo += "UnauthenticatedException:用户无上传图片权限";                    logger.error(resultInfo,g);                }                return resultInfo;            }        }    }    @Override    public String onlineUtils(HttpServletRequest request) {        return "/user/onlineUtils";    }    @Override    public List<String> detectImage(MultipartHttpServletRequest request,String description){        List<String> results = new ArrayList<>(2);        Long userId = (Long)SecurityUtils.getSubject().getSession().getAttribute("userId");        if (userId == null) {            results.add("用户未登录!");            return results;        }else{            if(description==null){                description="";            }            String resultInfo = "";            Timestamp dateTime = new Timestamp(new Date().getTime());            User user = redisDAO.getRedisUser(userId);            //缓存未命中，从数据库读user            if(user==null){                user = userMapper.selectByPrimaryKey(userId);            }            try {                Iterator<String> fileNames = request.getFileNames();                while (fileNames.hasNext()) {                    //把fileNames集合中的值打出来                    String fileName = fileNames.next();                    /*                     * request.getFiles(fileName)方法即通过fileName这个Key, 得到对应的文件                     * 集合列表. 只是在这个Map中, 文件被包装成MultipartFile类型                     */                    List<MultipartFile> fileList = request.getFiles(fileName);                    Picture picture = new Picture();                    picture.setUserid(userId);                    picture.setCreatedate(dateTime);                    //保存图片至临时文件夹                    String fileContextPath = TEMP_IMAGE_PATH + File.separator;                    String dirPath = NGINX_STATIC_DIRPATH + fileContextPath;                    File dir = new File(dirPath);                    if(!dir.exists()){                        dir.mkdirs();                    }                    //遍历文件列表                    Iterator<MultipartFile> fileIte = fileList.iterator();                    while (fileIte.hasNext()) {                        //获得每一个文件                        MultipartFile multipartFile = fileIte.next();                        //获得原文件名                        String originalFilename = multipartFile.getOriginalFilename();                        if ("" == originalFilename) {                            resultInfo += "空文件😶！;";                            continue;                        }                        resultInfo += ("原文件名:" + originalFilename + ";");                        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");                        String dateString = sdf.format(new Date());                        String newfileName =  userId.toString() + "_" + user.getUsername() + "_" + dateString + "_" +originalFilename;                        //上传图片至nginx目录                        File nginxFile = new File(dirPath + newfileName);                        if (!(nginxFile.exists())) {                            try{                                //此处若文件已存在,则会抛出IllegalStateException                                multipartFile.transferTo(nginxFile);                                nginxFile.setReadable(true, false);                            }catch (IllegalStateException i){                                System.out.println("IllegalStateException:文件已存在:"+nginxFile.getName());                            }                        }                        //上传图片至nginx下temp文件夹                        results.add(fileContextPath + newfileName);                        resultInfo += ("文件名:" + originalFilename + ";");                        //multipartFile.getSize()获取文件大小, 单位为字节,用工具类getPrintSize()处理后转化为B、MB、KB、GB                        String size = InfoCountUtils.getPrintSize(multipartFile.getSize());                        resultInfo += ("文件大小:" + size);                        if (multipartFile.getSize() > 0) {                            resultInfo += "图片已存服务器";                        }                    }                }            } catch (IllegalStateException f) {                resultInfo += "IllegalStateException:上传状态错误，可能是从非法页面提交上传";                logger.error(resultInfo,f);                f.printStackTrace();            } catch (UnauthenticatedException g) {                resultInfo += "UnauthenticatedException:用户无上传图片权限";                logger.error(resultInfo,g);            } catch (Exception e) {                resultInfo += "Exception:e";                logger.error(resultInfo,e);            } finally {                results.add(resultInfo);                return results;            }        }    }    @Override    public String shellExec(String command) throws Exception {        String returnString = "";        Process pro = null;        Runtime runTime = Runtime.getRuntime();        if (runTime == null) {            System.err.println("Create runtime false!");        }        try {            pro = runTime.exec(command);            BufferedReader input = new BufferedReader(new InputStreamReader(pro.getInputStream()));            PrintWriter output = new PrintWriter(new OutputStreamWriter(pro.getOutputStream()));            String line;            while ((line = input.readLine()) != null) {                returnString = returnString + line + "\n";            }            input.close();            output.close();            pro.destroy();        } catch (IOException ex) {            logger.error("shellExec exception:", ex);        }        return returnString.trim();    }    @Override    public List<String> downloadVideo(String url) {        List<String> results = new ArrayList<>();        String contextPath = TEMP_VIDEO_PATH + File.separator + UUID.randomUUID().toString();        String dirPath = "/usr/local/nginx/html" + contextPath;        try{            File file = new File(dirPath);            if(!file.exists()){                file.mkdirs();            }            if(StringUtils.contains(url, "zhihu.com")){                shellExec("python3 " + ZHIHU_DOWNLOADER_PATH + " " + url + " " + dirPath);            }else{                shellExec("annie -o " + dirPath + " " + url);            }            List<String> filenames = getVideoNames(dirPath);            if(filenames!=null&&filenames.size()>0){                filenames.parallelStream().forEach(e->{                    String filename = contextPath + File.separator + e;                    results.add(filename);                });            }else{                return null;            }        }catch (Exception e){            logger.error("downloadVideo Exception: ", e);        }        return results;    }    private List<String> getVideoNames(String dirPath){        List<String> names = null;        try{            names = new ArrayList<>();            String fs = shellExec("ls "+dirPath);            String[] paths = fs.trim().split("\n");            for(int i=0;i<paths.length; i++){                names.add(paths[i].trim());            }        }catch (Exception e){            return null;        }        return names;    }}